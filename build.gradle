import java.util.function.Consumer
import java.util.regex.Pattern
import groovy.json.*

buildscript {
    repositories {
        maven { url = 'https://files.minecraftforge.net/maven' }
        maven { url = 'https://maven.parchmentmc.org' }
        mavenLocal()
        mavenCentral()
        maven {
            url "https://plugins.gradle.org/m2/"
        }
        maven {
            name = 'ajoberstar-backup'
            url = 'https://ajoberstar.org/bintray-backup/'
        }
    }
    dependencies {
        classpath "net.minecraftforge.gradle:ForgeGradle:5.1.+"
        classpath "gradle.plugin.com.github.jengelman.gradle.plugins:shadow:7.0.0"
        classpath "gradle.plugin.com.matthewprenger:CurseGradle:1.4.0"
        classpath "de.undercouch:gradle-download-task:4.1.2"
        classpath "org.zaproxy.gradle:gradle-plugin-crowdin:0.2.1"
        classpath "org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:3.3"
        classpath 'org.ajoberstar:grgit:3.3'
        classpath 'org.parchmentmc:librarian:1.+'
    }
}

ext.opc = [
        splitVersionNumber: { String versionNumber ->
            return versionNumber.split("\\.");
        },

        buildVersionNumberWithOffset: { String sourceVersionNumber, String currentMCVersion, String relativeMCVersion, int versionElementIndex, int mcVersionElementIndex ->
            String[] sourceVersionElements = opc.splitVersionNumber(sourceVersionNumber);
            String[] currentMCVersionElements = opc.splitVersionNumber(currentMCVersion);
            String[] relativeMCVersionElements = opc.splitVersionNumber(relativeMCVersion);

            int mcVersion = Integer.parseInt(currentMCVersionElements[mcVersionElementIndex])
            int relativeMcVersion = Integer.parseInt(relativeMCVersionElements[mcVersionElementIndex])
            int offset = mcVersion - relativeMcVersion;

            String version = "";
            for (i in 0..<sourceVersionElements.length) {
                if (i != versionElementIndex)
                    version += sourceVersionElements[i];
                else
                    version += ((Integer.parseInt(sourceVersionElements[i]) + offset).toString())

                if (i != sourceVersionElements.length - 1)
                    version += "."
            }

            return version;
        },

        getEnvironmentPropertyName: { String propertyName ->
            String[] propertyNameElements = propertyName.split("(?=\\p{Upper})");
            return String.join("_", propertyNameElements).toUpperCase();
        },

        getProperty: { String propertyName ->
            if (project.hasProperty(propertyName) && project.getProperty(propertyName).toString().trim() != "") {
                return project.getProperty(propertyName).toString().trim()
            }

            String environmentPropertyName = opc.getEnvironmentPropertyName(propertyName);
            return System.getenv().containsKey(environmentPropertyName) ? System.getenv().get(environmentPropertyName).toString().trim() : ""
        },

        getIntProperty: { String propertyName ->
            if (project.hasProperty(propertyName) && project.getProperty(propertyName).toString().trim() != "") {
                return Integer.parseInt(project.getProperty(propertyName).toString().trim())
            }

            String environmentPropertyName = opc.getEnvironmentPropertyName(propertyName);
            return System.getenv().containsKey(environmentPropertyName) ? Integer.parseInt(System.getenv().get(environmentPropertyName).toString().trim()) : 0
        },


        getStringListProperty: { String propertyName ->
            if (!opc.hasPropertySet(propertyName)) {
                return new String[0];
            }

            String propertyValue = opc.getProperty(propertyName);
            String[] values = propertyValue.split(";")
            List<String> listValues = Arrays.asList(values);
            listValues.removeIf({value -> value == null || value.trim().isEmpty() })
            return listValues.toArray(String[]::new);
        },

        hasPropertySet: { String propertyName ->
            boolean result = opc.getProperty(propertyName) != "";
            return result;
        },

        capitalize: { String word ->
            return (word.length() == 0 ? "" : word.substring(0,1).toUpperCase() + (word.length() == 1 ? "" : word.substring(1)))
        },

        isFeatureEnabled: { String featureName ->
            String propertyValue = opc.getProperty("uses" + opc.capitalize(featureName));
            boolean enabled = propertyValue.toLowerCase() == "true";
            return enabled;
        },
]

if (opc.isFeatureEnabled("crowdin")) {
    apply plugin: de.undercouch.gradle.tasks.download.DownloadTaskPlugin
}

if (opc.isFeatureEnabled("crowdInTranslationManagement")) {
    apply plugin: org.zaproxy.gradle.crowdin.CrowdinPlugin
}

if (opc.isFeatureEnabled("sonarQube")) {
    apply plugin: org.sonarqube.gradle.SonarQubePlugin
}

apply plugin: 'java-library'

def projectUsesShadowing = false
if ((project.hasProperty("useShadowJar") && project.useShadowJar.toString().toLowerCase() == "true") ||
        (project.hasProperty("shadowRenamedNamespaces") &&  !project.shadowRenamedNamespaces.trim().isEmpty())
) {
    projectUsesShadowing = true
}

if (projectUsesShadowing) {
    apply plugin: com.github.jengelman.gradle.plugins.shadow.ShadowPlugin
}
if (opc.isFeatureEnabled("curse") && opc.hasPropertySet("curseId")
        && (opc.hasPropertySet("curseApiKey") || opc.hasPropertySet("CURSEAPIKEY"))
        && (opc.hasPropertySet("curseReleaseType") || opc.hasPropertySet("CURSERELEASETYPE"))) {
    apply plugin: com.matthewprenger.cursegradle.CurseGradlePlugin
}
apply plugin: net.minecraftforge.gradle.userdev.UserDevPlugin

if (opc.isFeatureEnabled("parchment")) {
    apply plugin: org.parchmentmc.librarian.forgegradle.LibrarianForgeGradlePlugin
}

apply plugin: 'jacoco'
apply plugin: 'maven-publish'
apply plugin: 'idea'
apply plugin: 'eclipse'

repositories {
    jcenter()
    mavenCentral()
    maven {
        name 'LDTTeam - Modding'
        url 'https://ldtteam.jfrog.io/ldtteam/modding/'
    }
    flatDir {
        dirs {
            "libs"
        }
    }
}

static HashSet<String> newSet(String... members) {
    def set = new HashSet<String>();
    set.addAll(members);
    return set;
}

ext.git = [
        repositry: new Object(),
        branch: new Object()
]
ext.git.repository = org.ajoberstar.grgit.Grgit.open(currentDir: file('.'))
ext.git.branch = git.repository.branch.getCurrent()

group = project.modGroup

if (opc.isFeatureEnabled("MCVersionBasedVersioning")
        && opc.hasPropertySet("mcVersionElementIndex")
        && opc.hasPropertySet("sourceVersionElementIndex")
        && opc.hasPropertySet("sourceVersionName")) {
    logger.lifecycle("MC based versioning active")

    version = opc.buildVersionNumberWithOffset(
            (System.getenv().containsKey("Version") ? System.getenv("Version") : project.modVersion),
            project.exactMinecraftVersion,
            opc.getProperty("sourceVersionName"),
            opc.getIntProperty("sourceVersionElementIndex"),
            opc.getIntProperty("mcVersionElementIndex")
    )
}
else
{
    version = project.exactMinecraftVersion + "-" + (System.getenv().containsKey("Version") ? System.getenv("Version") : project.modVersion)
}
archivesBaseName = project.modId
project.properties.file = [
        jarVersion: project.version
];

project.logger.lifecycle("Starting Gradle build for: " + project.modId + " with version: " + project.version)

def projectHasApi = true;
if (project.hasProperty("projectHasApi")) {
    projectHasApi = project.projectHasApi.toString().toLowerCase() == "true"

    if (!projectHasApi) {
        project.logger.lifecycle "Disabling API systems."
    }
}

def defaultSourceSetConfigurationDependencies = new HashSet<String>();
def availableSourceSets = new LinkedHashSet<String>();
def sourceSetConfigurationDependencies = new HashMap<String, Set<String>>();
def sourceSetSourceSetDependencies = new HashMap<String, Set<String>>();
def sourceSetAdditionalResourceDirectories = new HashMap<String, Set<String>>();
def sourceSetExcludedResourceDefinitions = new HashMap<String, Set<String>>();
def sourceSetIncludedResourceDefinitions = new HashMap<String, Set<String>>();
def sourceSetClassifiers = new HashMap<String, String>();

defaultSourceSetConfigurationDependencies.add("minecraft");

if (projectHasApi) {
    availableSourceSets.add("api");
}
availableSourceSets.add("main");
availableSourceSets.add("test");

sourceSetClassifiers.put("api", "api");
sourceSetClassifiers.put("main", "");
sourceSetClassifiers.put("test", "test");

if (projectHasApi) {
    sourceSetConfigurationDependencies.put("api", defaultSourceSetConfigurationDependencies);

    sourceSetSourceSetDependencies.put("main", newSet("api"));
    sourceSetSourceSetDependencies.put("test", newSet("api"));
}

sourceSetAdditionalResourceDirectories.put("main", newSet("src/datagen/generated/${project.modId}"))
sourceSetExcludedResourceDefinitions.put("main", newSet(".cache"))
sourceSetIncludedResourceDefinitions.put("main", newSet("**/**"))

void loadSourceSetConfiguration(Project project, String sourceSetName
                                , HashMap<String, Set<String>> sourceSetConfigurationDependencies
                                , HashMap<String, Set<String>> sourceSetSourceSetDependencies
                                , HashMap<String, Set<String>> sourceSetAdditionalResourceDirectories
                                , HashMap<String, Set<String>> sourceSetExcludedResourceDefinitions
                                , HashMap<String, Set<String>> sourceSetIncludedResourceDefinitions
                                , HashMap<String, String> sourceSetClassifiers
) {
    def configurationDependenciesPropertyName = sourceSetName + "ConfigurationDependencies"
    def sourceSetDependenciesPropertyName = sourceSetName + "SourceSetDependencies"
    def additionalResourcesPropertyName = sourceSetName + "ResourceDirectories"
    def excludeResourcesPropertyName = sourceSetName + "ExcludedResources"
    def includeResourcesPropertyName = sourceSetName + "IncludedResources"
    def customClassifierPropertyName = sourceSetName + "Classifier"

    if (project.hasProperty(configurationDependenciesPropertyName)) {
        sourceSetConfigurationDependencies.putIfAbsent(sourceSetName, new HashSet<String>())
        Arrays.stream(project[configurationDependenciesPropertyName].split(";")).forEach(new Consumer<String>() {
            @Override
            void accept(final String o) {
                sourceSetConfigurationDependencies.get(sourceSetName).add(o)
            }
        })
    }

    if (project.hasProperty(sourceSetDependenciesPropertyName)) {
        sourceSetSourceSetDependencies.putIfAbsent(sourceSetName, new HashSet<String>())
        Arrays.stream(project[sourceSetDependenciesPropertyName].split(";")).forEach(new Consumer<String>() {
            @Override
            void accept(final String o) {
                sourceSetSourceSetDependencies.get(sourceSetName).add(o)
            }
        })
    }

    if (project.hasProperty(additionalResourcesPropertyName)) {
        sourceSetAdditionalResourceDirectories.putIfAbsent(sourceSetName, new HashSet<String>())
        Arrays.stream(project[additionalResourcesPropertyName].split(";")).forEach(new Consumer<String>() {
            @Override
            void accept(final String o) {
                sourceSetAdditionalResourceDirectories.get(sourceSetName).add(o)
            }
        })
    }

    if (project.hasProperty(excludeResourcesPropertyName)) {
        sourceSetExcludedResourceDefinitions.putIfAbsent(sourceSetName, new HashSet<String>())
        Arrays.stream(project[excludeResourcesPropertyName].split(";")).forEach(new Consumer<String>() {
            @Override
            void accept(final String o) {
                sourceSetExcludedResourceDefinitions.get(sourceSetName).add(o)
            }
        })
    }

    if (project.hasProperty(includeResourcesPropertyName)) {
        sourceSetIncludedResourceDefinitions.putIfAbsent(sourceSetName, new HashSet<String>())
        Arrays.stream(project[includeResourcesPropertyName].split(";")).forEach(new Consumer<String>() {
            @Override
            void accept(final String o) {
                sourceSetIncludedResourceDefinitions.get(sourceSetName).add(o)
            }
        })
    }

    if (project.hasProperty(customClassifierPropertyName)) {
        sourceSetClassifiers.put(sourceSetName, project.customClassifierPropertyName)
    }
}

if (project.hasProperty("extendDefaultSourceSetConfiguration") && project.extendDefaultSourceSetConfiguration.toString().toLowerCase() == "true") {
    def additionalAvailableSourceSets = new HashSet<String>();
    if (project.hasProperty("additionalSourceSets")) {
        Arrays.stream(project.additionalSourceSets.split(";")).forEach(additionalAvailableSourceSets::add)
    }

    availableSourceSets.addAll(additionalAvailableSourceSets);
    additionalAvailableSourceSets.forEach(customSourceSetName -> {
        project.logger.lifecycle "Loading additional source set: ${customSourceSetName}"

        loadSourceSetConfiguration(project, customSourceSetName,
                sourceSetConfigurationDependencies
                , sourceSetSourceSetDependencies
                , sourceSetAdditionalResourceDirectories
                , sourceSetExcludedResourceDefinitions
                , sourceSetIncludedResourceDefinitions
                , sourceSetClassifiers);
    })

    if (projectHasApi) {
        loadSourceSetConfiguration(project, "api",
                sourceSetConfigurationDependencies
                , sourceSetSourceSetDependencies
                , sourceSetAdditionalResourceDirectories
                , sourceSetExcludedResourceDefinitions
                , sourceSetIncludedResourceDefinitions
                , sourceSetClassifiers);
    }
    loadSourceSetConfiguration(project, "main",
            sourceSetConfigurationDependencies
            , sourceSetSourceSetDependencies
            , sourceSetAdditionalResourceDirectories
            , sourceSetExcludedResourceDefinitions
            , sourceSetIncludedResourceDefinitions
            , sourceSetClassifiers);
    loadSourceSetConfiguration(project, "test",
            sourceSetConfigurationDependencies
            , sourceSetSourceSetDependencies
            , sourceSetAdditionalResourceDirectories
            , sourceSetExcludedResourceDefinitions
            , sourceSetIncludedResourceDefinitions
            , sourceSetClassifiers);
}

availableSourceSets.forEach(sourceSetName -> {
    project.logger.lifecycle "Configuring source set: ${sourceSetName}"
    def sourceSet = project.sourceSets.maybeCreate(sourceSetName)

    sourceSet.java.srcDir "src/${sourceSetName}/java"
    sourceSet.resources.srcDir "src/${sourceSetName}/resources"

    if (sourceSetConfigurationDependencies.containsKey(sourceSetName)) {
        def configurationDependencies = sourceSetConfigurationDependencies.get(sourceSetName);
        configurationDependencies.forEach(configurationName -> {
            project.logger.lifecycle " > Adding configuration: ${configurationName} as a dependency..."
            sourceSet.compileClasspath += project.configurations.getByName(configurationName);
        })
    }

    if (sourceSetSourceSetDependencies.containsKey(sourceSetName)) {
        def sourceSetDependencies = sourceSetSourceSetDependencies.get(sourceSetName)
        sourceSetDependencies.forEach(otherSourceSetName -> {
            project.logger.lifecycle " > Adding source set: ${otherSourceSetName} as a dependency..."
            def otherSourceSet = project.sourceSets.maybeCreate(otherSourceSetName);

            sourceSet.compileClasspath += otherSourceSet.output;
            sourceSet.runtimeClasspath += otherSourceSet.output;
        })
    }

    if (sourceSetIncludedResourceDefinitions.containsKey(sourceSetName)) {
        def includeDefinitions = sourceSetIncludedResourceDefinitions.get(sourceSetName)
        includeDefinitions.forEach(definition -> {
            project.logger.lifecycle " > Adding: ${definition} as an resource include spec..."
            sourceSet.resources.include definition
        })
    }

    if (sourceSetAdditionalResourceDirectories.containsKey(sourceSetName)) {
        def additionalResourceDirectories = sourceSetAdditionalResourceDirectories.get(sourceSetName);
        additionalResourceDirectories.forEach(directory -> {
            project.logger.lifecycle " > Adding: ${directory} as an resource directory..."
            sourceSet.resources.srcDirs += directory
        })
    }

    if (sourceSetExcludedResourceDefinitions.containsKey(sourceSetName)) {
        def excludeDefinitions = sourceSetExcludedResourceDefinitions.get(sourceSetName)
        excludeDefinitions.forEach(definition -> {
            project.logger.lifecycle " > Adding: ${definition} as an resource exclude spec..."
            sourceSet.resources.exclude definition
        })
    }
})

configurations {
    contained {
        transitive = false
    }
}

if (project.useJavaToolChains.toString().toLowerCase() == "true") {
    java.toolchain.languageVersion = JavaLanguageVersion.of(project.javaVersion)
} else {
    sourceCompatibility = targetCompatibility = compileJava.sourceCompatibility = compileJava.targetCompatibility = project.javaVersion
}

def primaryJarSourceSets = new HashSet<String>()
if (projectHasApi) {
    primaryJarSourceSets.add("api")
}
primaryJarSourceSets.add("main")
if (project.hasProperty("primaryJarSourceSets")) {
    primaryJarSourceSets.clear();
    Arrays.stream(project.primaryJarSourceSets.split(";")).forEach(sourceSetName -> primaryJarSourceSets.add(sourceSetName as String))
}

def runtimeSourceSets = new HashSet<String>()
runtimeSourceSets.addAll(primaryJarSourceSets);
if (project.hasProperty("runtimeSourceSets")) {
    runtimeSourceSets.clear();
    Arrays.stream(project.runtimeSourceSets.split(";")).forEach(sourceSetName -> runtimeSourceSets.add(sourceSetName as String))
}

def librarySourceSets = new HashSet<String>()
runtimeSourceSets.addAll(librarySourceSets);
if (project.hasProperty("librarySourceSets")) {
    librarySourceSets.clear();
    opc.getStringListProperty("librarySourceSets").each {String sourceSetName -> librarySourceSets.add(sourceSetName as String) }
}

def libraryConfigs = new HashSet<org.gradle.api.artifacts.Configuration>();
configurations { configContainer ->
    librarySourceSets.each { sourceSetName ->
        def configName = sourceSetName == "main" ? "library" : sourceSetName + "Library";
        def implementationConfigName = sourceSetName == "main" ? "implementation" : sourceSetName + "Implementation"

        project.getLogger().lifecycle(" > Adding configuration as library target: ${configName}...")
        def libraryConfig = configContainer.maybeCreate(configName)
        def implementationConfig = configContainer.maybeCreate(implementationConfigName)

        implementationConfig.extendsFrom libraryConfig

        libraryConfigs.add(libraryConfig);
    }
}

project.minecraft {
    mappings channel: project.mappingsChannel, version: project.mappingsVersion
    accessTransformer = file('src/main/resources/META-INF/accesstransformer.cfg')

    runs { runSpecContainer ->
        def clientSpec = runSpecContainer.maybeCreate("client")
        clientSpec.workingDirectory project.file('run')
        clientSpec.property 'forge.logging.markers', ''
        clientSpec.property 'forge.logging.console.level', 'info'
        clientSpec.property 'mixin.env.remapRefMap', 'true'
        clientSpec.property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"
        clientSpec.mods { n ->
            def mod = n.create(project.modId);
            runtimeSourceSets.forEach(sourceSetName -> {
                def sourceSet = project.sourceSets[sourceSetName]
                mod.source(sourceSet)
            })
        }
        if (opc.isFeatureEnabled("randomUsernames")) {
            var randomAppendix = (Math.abs(new Random().nextInt() % 600) + 1).toString();
            clientSpec.args '--username', "Dev{$randomAppendix}"
        }

        def serverSpec = runSpecContainer.maybeCreate("server")
        serverSpec.workingDirectory project.file('run')
        serverSpec.property 'forge.logging.markers', ''
        serverSpec.property 'forge.logging.console.level', 'info'
        serverSpec.property 'mixin.env.remapRefMap', 'true'
        serverSpec.property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"
        serverSpec.mods { n ->
            def mod = n.create(project.modId);
            runtimeSourceSets.forEach(sourceSetName -> {
                def sourceSet = project.sourceSets[sourceSetName]
                mod.source(sourceSet)
            })
        }

        if (opc.isFeatureEnabled("datagen")) {
            def dataSpec = runSpecContainer.maybeCreate("data")
            dataSpec.workingDirectory project.file('run')
            dataSpec.property 'forge.logging.markers', ''
            dataSpec.property 'forge.logging.console.level', 'info'
            dataSpec.property 'mixin.env.remapRefMap', 'true'
            dataSpec.property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"
            dataSpec.args '--all', '--output', file("src/datagen/generated/${project.modId}"),
                    '--mod', "${project.modId}".toString(),
                    '--existing', sourceSets.main.resources.srcDirs[0]
            dataSpec.mods { n ->
                def mod = n.create(project.modId);
                runtimeSourceSets.forEach(sourceSetName -> {
                    def sourceSet = project.sourceSets[sourceSetName]
                    mod.source(sourceSet)
                })
            }
        }

        project.afterEvaluate {
            def paths = new HashSet<String>();
            libraryConfigs.each { config ->
                config.copyRecursive().resolve().collect { it.absolutePath.toString() }.each {path -> paths.add(path)}
            }

            runSpecContainer.each {runSpec ->
                runSpec.lazyToken('minecraft_classpath') {
                    paths.join(File.pathSeparator)
                }
            }
        }
    }
}


def useDefaultTestSystem = true;
def testSourceSets = new HashSet<String>();
def annotatedSourceSets = availableSourceSets;

testSourceSets.add("test");

if (project.hasProperty("useDefaultTestSystem") && project.useDefaultTestSystem.toString().toLowerCase() != "true") {
    useDefaultTestSystem = false;
}
if (project.hasProperty("testSourceSets")) {
    testSourceSets.clear();
    Arrays.stream(project.testSourceSets.split(";")).forEach(sourceSetName -> testSourceSets.add(sourceSetName as String))
}
if (project.hasProperty("annotatedSourceSets")) {
    annotatedSourceSets.clear();
    Arrays.stream(project.annotatedSourceSets.split(";")).forEach(sourceSetName -> annotatedSourceSets.add(sourceSetName as String))
}

if (useDefaultTestSystem) {
    def jUnitVersion = "4.13"
    def mockitoCoreVersion = "1.+"
    def powerMockModuleJUnit4Version = "2.0.2"
    def powerMockApiMockitoVersion = "2.0.2"
    def powerMockModuleJUnit4RuleEngineVersion = "2.0.2"
    def assertJCoreVersion = "3.9.0"
    def hamcrestAllVersion = "1.3"

    if (project.hasProperty("jUnitVersion")) {
        jUnitVersion = project.jUnitVersion;
    }
    if (project.hasProperty("mockitoCoreVersion")) {
        mockitoCoreVersion = project.mockitoCoreVersion;
    }
    if (project.hasProperty("powerMockVersion")) {
        powerMockModuleJUnit4Version = project.powerMockVersion;
        powerMockApiMockitoVersion = project.powerMockVersion;
        powerMockModuleJUnit4RuleEngineVersion = project.powerMockVersion;
    }
    if (project.hasProperty("powerMockModuleJUnit4Version")) {
        powerMockModuleJUnit4Version = project.powerMockModuleJUnit4Version;
    }
    if (project.hasProperty("powerMockApiMockitoVersion")) {
        powerMockApiMockitoVersion = project.powerMockApiMockitoVersion;
    }
    if (project.hasProperty("powerMockModuleJUnit4RuleEngineVersion")) {
        powerMockModuleJUnit4RuleEngineVersion = project.powerMockModuleJUnit4RuleEngineVersion;
    }
    if (project.hasProperty("assertJCoreVersion")) {
        assertJCoreVersion = project.assertJCoreVersion;
    }
    if (project.hasProperty("hamcrestAllVersion")) {
        hamcrestAllVersion = project.hamcrestAllVersion;
    }

    testSourceSets.forEach(sourceSetName -> {
        def configurationName = sourceSetName + "Implementation"
        if (sourceSetName == "main") {
            configurationName = "implementation"
        }

        dependencies.add(configurationName,  "junit:junit:${jUnitVersion}");
        dependencies.add(configurationName,  "org.mockito:mockito-core:${mockitoCoreVersion}");
        dependencies.add(configurationName,  "org.powermock:powermock-module-junit4:${powerMockModuleJUnit4Version}");
        dependencies.add(configurationName,  "org.powermock:powermock-api-mockito2:${powerMockApiMockitoVersion}");
        dependencies.add(configurationName,  "org.powermock:powermock-module-junit4-rule-agent:${powerMockModuleJUnit4RuleEngineVersion}");
        dependencies.add(configurationName,  "org.assertj:assertj-core:${assertJCoreVersion}");
        dependencies.add(configurationName,  "org.hamcrest:hamcrest-all:${hamcrestAllVersion}");
    })
}

def intelliJAnnotationsVersion = "21.0.1"
if (project.hasProperty("intelliJAnnotationsVersion")) {
    intelliJAnnotationsVersion = project.intelliJAnnotationsVersion;
}

annotatedSourceSets.forEach(sourceSetName -> {
    def configurationName = sourceSetName + "Implementation"
    if (sourceSetName == "main") {
        configurationName = "implementation"
    }

    dependencies.add(configurationName,  "org.jetbrains:annotations:${intelliJAnnotationsVersion}");
})

dependencies {
    minecraft "net.minecraftforge:forge:${project.exactMinecraftVersion}-${project.forgeVersion}"
}

def primaryJarClassifier = 'universal'
if (project.hasProperty("primaryJarClassifier")) {
    primaryJarClassifier = project.primaryJarClassifier;
}

def automaticModuleName = project.modId
if (project.hasProperty("automaticModuleName")) {
    automaticModuleName = project.automaticModuleName;
}

def isFMLLibrary = false;
if (project.hasProperty("isFMLLibrary") && project.isFMLLibrary.toString().toLowerCase() == "true") {
    isFMLLibrary = true;
}

processResources {
    outputs.upToDateWhen { false }

    def props = ["version":version]
    filesMatching ('**/mods.toml') {
        expand project.properties
    }
    doLast {
        if (project.usesMergableTranslations) {
            def slurper = new JsonSlurper()
            def standard = null

            def i = 0

            while (true) {
                def key = "translationMergeSources["+ i++ +"]"
                if (!project.hasProperty(key)) {
                    break;
                }

                def el = project.property(key)

                if(file(el).exists()) {
                    if (standard == null) {
                        standard = slurper.parse(file(el), 'UTF-8')
                    }
                    else {
                        standard += slurper.parse(file(el), 'UTF-8')
                    }
                }
            }
            file(project.translationMergeDestination1).write(JsonOutput.prettyPrint(JsonOutput.toJson(standard)), 'UTF-8')
            file(project.translationMergeDestination2).write(JsonOutput.prettyPrint(JsonOutput.toJson(standard)), 'UTF-8')
        }
    }
}

jar {
    primaryJarSourceSets.forEach(sourceSetName -> {
        project.jar.from project.sourceSets[sourceSetName].output
    })

    classifier primaryJarClassifier
    if (projectUsesShadowing) {
        classifier 'slim'
    }

    manifest {
        attributes([
                'Maven-Artifact'          : "${project.group}:${project.archivesBaseName}:${project.version}",
                "Specification-Title"     : project.modId,
                "Specification-Vendor"    : "ldtteam",
                "Specification-Version"   : "1", // We are version 1 of ourselves
                "Implementation-Title"    : project.name,
                "Implementation-Version"  : "${project.version}",
                "Implementation-Vendor"   : "ldtteam",
                "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
                "Automatic-Module-Name"   : automaticModuleName
        ])

        if (isFMLLibrary) {
            attributes([
                    'FMLModType'          : "LIBRARY",
            ])
        }
    }
}

def additionalSourceSetJars = new HashSet<String>();
if (projectHasApi) {
    additionalSourceSetJars.add("api")
}
if (project.hasProperty("additionalSourceSetJars")) {
    additionalSourceSetJars.clear();
    Arrays.stream(project.additionalSourceSetJars.split(";")).forEach(sourceSetName -> additionalSourceSetJars.add(sourceSetName as String))
}

additionalSourceSetJars.forEach(additionalSourceSet -> {
    String additionalSourceSetJavaDocTaskName = additionalSourceSet + "Javadoc"
    String additionalSourceSetPackageJavaDocTaskName = additionalSourceSet + "PackageJavadoc"
    String additionalSourceSetJarTaskName = additionalSourceSet + "Jar"
    String additionalSourceSetSourcesTaskName = additionalSourceSet + "Sources"
    String additionalSourceSetBuildTask = additionalSourceSet + "Build"

    String additionalSourceSetJavadocClassifier = sourceSetClassifiers.getOrDefault(additionalSourceSet, additionalSourceSet.toLowerCase()) + "-javadoc"
    String additionalSourceSetSourcesClassifier = sourceSetClassifiers.getOrDefault(additionalSourceSet, additionalSourceSet.toLowerCase()) + "-sources"

    org.gradle.api.tasks.javadoc.Javadoc javaDocTask = project.tasks.create(additionalSourceSetJavaDocTaskName, Javadoc.class);
    javaDocTask.setClasspath(sourceSets[additionalSourceSet].getCompileClasspath())
    javaDocTask.group 'documentation'
    javaDocTask.source = sourceSets[additionalSourceSet].allJava
    javaDocTask.destinationDir = project.buildDir.toPath().resolve("additional").resolve("javadoc").resolve(additionalSourceSet).toFile()

    org.gradle.api.tasks.bundling.Jar javadocJarTask = project.tasks.create(additionalSourceSetPackageJavaDocTaskName, org.gradle.api.tasks.bundling.Jar.class)
    javadocJarTask.dependsOn javaDocTask
    javadocJarTask.group 'packaging'
    javadocJarTask.from javaDocTask
    javadocJarTask.getArchiveClassifier().set(additionalSourceSetJavadocClassifier)

    org.gradle.api.tasks.bundling.Jar outputJarTask = project.tasks.create(additionalSourceSetJarTaskName, org.gradle.api.tasks.bundling.Jar.class)
    outputJarTask.group 'build'
    outputJarTask.from sourceSets[additionalSourceSet].output
    outputJarTask.getArchiveClassifier().set(additionalSourceSet.toLowerCase())

    org.gradle.api.tasks.bundling.Jar sourcesJarTask = project.tasks.create(additionalSourceSetSourcesTaskName, org.gradle.api.tasks.bundling.Jar.class)
    sourcesJarTask.group 'sources'
    sourcesJarTask.duplicatesStrategy 'exclude'
    sourcesJarTask.from sourceSets[additionalSourceSet].allJava
    sourcesJarTask.getArchiveClassifier().set(additionalSourceSetSourcesClassifier)

    Task sourceSetBuildTask = project.tasks.create(additionalSourceSetBuildTask)
    sourceSetBuildTask.group 'build'
    sourceSetBuildTask.dependsOn javaDocTask
    sourceSetBuildTask.dependsOn javadocJarTask
    sourceSetBuildTask.dependsOn outputJarTask
    sourceSetBuildTask.dependsOn sourcesJarTask

    project.tasks.build.dependsOn sourceSetBuildTask
})

task sourcesJar(type: Jar) { it ->
    classifier = 'sources'
    duplicatesStrategy 'exclude'

    primaryJarSourceSets.forEach(sourceSetName -> {
        it.from project.sourceSets[sourceSetName].allSource
    })
}

javadoc {it ->
    primaryJarSourceSets.forEach(sourceSetName -> {
        it.source +=  project.sourceSets[sourceSetName].allJava
    })
}

task packageJavadoc(type: Jar) { task ->
    task.dependsOn javadoc
    task.from javadoc
    task.classifier = 'javadoc'
}

project.tasks.build.dependsOn sourcesJar
project.tasks.build.dependsOn packageJavadoc


if (projectUsesShadowing) {
    shadowJar { shadowJarTask ->
        primaryJarSourceSets.forEach(sourceSetName -> {
            shadowJarTask.from project.sourceSets[sourceSetName].output
        })

        shadowJarTask.configurations = [project.configurations.contained]

        if (project.hasProperty("shadowRenamedNamespaces") && !project.shadowRenamedNamespaces.trim().isEmpty()) {
            project.shadowRenamedNamespaces.split(',').each { n ->
                if (n.contains(':')) {
                    def namespaceSpecs = n.split(':');
                    project.logger.lifecycle "Shading ${namespaceSpecs[0]} to ${namespaceSpecs[1]}"
                    shadowJarTask.relocate namespaceSpecs[0], namespaceSpecs[1]
                }
            }
        }

        shadowJarTask.classifier = primaryJarClassifier
    }
}


def reobfuscationSourceSets = new HashSet<String>();
if (projectHasApi) {
    reobfuscationSourceSets.add("api");
}
reobfuscationSourceSets.add("main");
if (project.hasProperty("reobfuscationSourceSets")) {
    reobfuscationSourceSets.clear();
    Arrays.stream(project.reobfuscationSourceSets.split(";")).forEach(sourceSetName -> reobfuscationSourceSets.add(sourceSetName as String))
}

def reobfuscationContainer = project.reobf
reobfuscationSourceSets.forEach(sourceSetName -> {
    def sourceSet = project.sourceSets[sourceSetName]
    def taskName = sourceSetName + "Jar"
    if (sourceSetName == "main") {
        taskName = "jar"
    }

    def task = reobfuscationContainer.create(taskName)
    task.getClasspath().from(sourceSet.getCompileClasspath())
    task.group 'reobfuscation'

    if (sourceSetName == "main" && projectUsesShadowing) {
        taskName = "shadowJar"
        def shadowTask = reobfuscationContainer.create(taskName)
        shadowTask.group 'reobfuscation'
        shadowTask.getClasspath().from(sourceSet.getCompileClasspath())
    }
})

def publishableSourceSets = new HashSet<String>()
if (projectHasApi) {
    publishableSourceSets.add("api")
}
publishableSourceSets.add("main")
if (project.hasProperty("publishableSourceSets")) {
    publishableSourceSets.clear();
    Arrays.stream(project.publishableSourceSets.split(";")).forEach(sourceSetName -> publishableSourceSets.add(sourceSetName as String))
}

artifacts { it ->
    publishableSourceSets.forEach(sourceSetName -> {
        String javaDocTaskName = sourceSetName + "PackageJavadoc"
        String jarTaskName = sourceSetName + "Jar"
        String sourceTaskName = sourceSetName + "Sources"
        if (sourceSetName == "main") {
            javaDocTaskName = "packageJavadoc"
            jarTaskName = "jar"
            sourceTaskName = "sourcesJar"
        }

        it.add("default", project.tasks[javaDocTaskName])
        it.add("default", project.tasks[jarTaskName])
        it.add("default", project.tasks[sourceTaskName])

        if (sourceSetName == "main" && projectUsesShadowing) {
            it.add("default", project.tasks.shadowJar);
        }
    })
}

publishing {
    publications {
        mavenJava(MavenPublication) {pub ->
            from project.components.java

            artifactId project.modId

            publishableSourceSets.forEach(sourceSetName -> {
                String javaDocTaskName = sourceSetName + "PackageJavadoc"
                String jarTaskName = sourceSetName + "Jar"
                String sourceTaskName = sourceSetName + "Sources"
                if (sourceSetName == "main") {
                    javaDocTaskName = "packageJavadoc"
                    jarTaskName = "jar"
                    sourceTaskName = "sourcesJar"
                }

                pub.artifacts.artifact(project.tasks[javaDocTaskName])
                if (sourceSetName != "main") {
                    pub.artifacts.artifact(project.tasks[jarTaskName])
                }
                pub.artifacts.artifact(project.tasks[sourceTaskName])
            })

            pom {
                url = project.githubUrl
                licenses {
                    license {
                        name = 'GNU GENERAL PUBLIC LICENSE Version 3'
                        url = 'https://www.gnu.org/licenses/gpl-3.0.en.html'
                    }
                }
                developers {
                    developer {
                        id = 'OrionDevelopment'
                        name = 'Marc Hermans'
                        email = 'marc.hermans@ldtteam.com'
                    }
                    developer {
                        id = 'Raycoms'
                        name = 'Ray Neiheiser'
                        email = 'ray.neiheiser@ldtteam.com'
                    }
                }
                contributors {
                    contributor {
                        id = 'ldtteam'
                        name = 'Let\'s Develop Together - Team'
                        email = 'info@ldtteam.com'
                    }
                }
                scm {
                    connection = project.gitUrl
                    developerConnection = project.gitConnectUrl
                    url = project.projectUrl
                }
            }

            //Replace all deobf dependencies with normal jar references.
            pom.withXml { xmlProvider ->
                def dependencies = asNode().dependencies
                def allDeps = dependencies.'*';

                allDeps.findAll {
                    println it
                }

                // Remove forge deps
                allDeps.findAll() { el ->
                    el.artifactId.text() == 'forge' && el.groupId.text() == 'net.minecraftforge'
                }.forEach() { el ->
                    el.parent().remove(el)
                }
                //remove forgegradle's mapped suffix from versions & set as optional so anyone else doesn't inherit them
                allDeps.findAll() { el ->
                    el.version.text().contains('_mapped_')
                }.each { el ->
                    def version = el.version
                    version.each {
                        it.setValue(it.text().substring(0, it.text().indexOf('_mapped_')))
                    }
                }
            }
        }
    }

    if (System.getenv().containsKey("LDTTeamJfrogUsername") && System.getenv().containsKey("LDTTeamJfrogPassword")) {
        repositories {
            maven {
                name 'LDTTeamJfrog'
                credentials {
                    username System.getenv().get("LDTTeamJfrogUsername")
                    password System.getenv().get("LDTTeamJfrogPassword")
                }
                url 'https://ldtteam.jfrog.io/ldtteam/mods-maven'
            }
        }
    }

    repositories {
        maven {
            name 'RepoDirectory'
            url 'file://' + rootProject.file('repo').getAbsolutePath()
        }
    }
}

task setupDecompWorkspace {
    doLast {
    }
}

task setupCIWorkspace {
    doLast {
    }
}

if (opc.isFeatureEnabled("curse") && opc.hasPropertySet("curseId")
        && (opc.hasPropertySet("curseApiKey") || opc.hasPropertySet("CURSEAPIKEY"))
        && (opc.hasPropertySet("curseReleaseType") || opc.hasPropertySet("CURSERELEASETYPE"))) {
    project.curseforge { cf ->
        cf.apiKey = opc.hasPropertySet("curseApiKey") ? opc.getProperty("curseApiKey") : opc.getProperty("CURSEAPIKEY")

        project { cp ->
            cp.id = opc.getProperty("curseId")
            cp.addGameVersion(project.exactMinecraftVersion)
            cp.changelog = file('build/changelog.md')
            cp.changelogType = 'markdown'
            cp.releaseType = opc.hasPropertySet("curseReleaseType") ? opc.getProperty("curseReleaseType") : opc.getProperty("CURSERELEASETYPE")

            opc.getStringListProperty("additionalMinecraftVersions").each { v ->
                cp.addGameVersion(v)
            }

            if (projectUsesShadowing) {
                cp.mainArtifact(shadowJar)
            } else {
                cp.mainArtifact(jar)
            }

            publishableSourceSets.forEach(sourceSetName -> {
                String javaDocTaskName = sourceSetName + "PackageJavadoc"
                String jarTaskName = sourceSetName + "Jar"
                String sourceTaskName = sourceSetName + "Sources"
                if (sourceSetName == "main") {
                    javaDocTaskName = "packageJavadoc"
                    jarTaskName = "jar"
                    sourceTaskName = "sourcesJar"
                }

                cp.addArtifact(project.tasks[javaDocTaskName])
                if (sourceSetName != "main" || projectUsesShadowing) {
                    cp.addArtifact(project.tasks[jarTaskName])
                }
                cp.addArtifact(project.tasks[sourceTaskName])
            })

            if (opc.hasPropertySet("requiredCurseDependencies") || opc.hasPropertySet("optionalCurseDependencies")) {
                cp.relations { relSpec ->
                    if (opc.hasPropertySet("requiredCurseDependencies")) {
                        opc.getStringListProperty("requiredCurseDependencies").each {depId ->
                            relSpec.requiredDependency depId
                        }
                    }

                    if (opc.hasPropertySet("optionalCurseDependencies")) {
                        opc.getStringListProperty("optionalCurseDependencies").each {depId ->
                            relSpec.optionalDependency depId
                        }
                    }
                }
            }
        }
    }

    task("createChangelog") {
        group = 'upload'

        doLast {
            def teamCityURL = "https://buildsystem.ldtteam.com/"
            project.rootProject.file("build/changelog.md").parentFile.mkdirs()
            def file = new FileOutputStream(project.rootProject.file("build/changelog.md"))
            def out = new BufferedOutputStream(file)
            def changesXML = new XmlSlurper().parse(teamCityURL + "guestAuth/app/rest/changes?locator=build:(id:" + teamcity["teamcity.build.id"] + ")")

            def changes = changesXML.change
            out << "# ${project.modId} Changelog \n"
            out << "## Version: _" + version + "_ \n"
            out << "## Structurize Version: _" + ${project.structurize_version} + "_ \n"

            if (opc.hasPropertySet("customChangelogHeader")) {
                out << opc.getProperty("customChangelogHeader")
            }

            if (changes.size() > 0) {
                for (int i = 0; i < changes.size(); i++) {
                    def changeDetailsURL = teamCityURL + "guestAuth/app/rest/changes/id:" + changes[i].@id.text()
                    def changeDetailsXml = new XmlSlurper().parse(changeDetailsURL)
                    def changeComment = changeDetailsXml.comment.text().trim()

                    out << "* " + changeComment + "\n"
                }
            } else {
                out << "No Changes detected!"
            }

            out.close()
        }
    }
}
else
{
    project.logger.lifecycle("Deactivating curse. Feature state: " + opc.isFeatureEnabled("curse") + " project id supplied: " + opc.hasPropertySet("curseId") + " api key supplied: " + (opc.hasPropertySet("curseApiKey") || opc.hasPropertySet("CURSEAPIKEY")) + " release type defined: " + (opc.hasPropertySet("curseReleaseType") || opc.hasPropertySet("CURSERELEASETYPE")))

    task("curseforge") {
        //Noop
    }

    task("createChangelog") {
        //Noop
    }
}


idea {
    module {
        inheritOutputDirs = true
    }
}


if (project.hasProperty("usesCrowdin") && project.usesCrowdin.toString().toLowerCase() == "true" &&
        System.getenv().containsKey("crowdinKey") && !project.gradle.startParameter.isOffline()) {
    task downloadCrowdin() {
        ext {
            output = file('build/crowdin_raw.zip')
            update = file('build/crowdin.json')
            id = project.crowdinId
        }
        onlyIf {
            System.getenv().containsKey("crowdinKey") && !project.gradle.startParameter.isOffline()
        }
        doLast {
            download {
                src "https://api.crowdin.com/api/project/${id}/export?key=${System.getenv("crowdinKey")}&json"
                dest update
                overwrite true
            }
            if (!update.text.contains('success')) {
                throw new RuntimeException("Crowdin export failed, see ${update} for more info")
            }
            download {
                src "https://api.crowdin.com/api/project/${id}/download/all.zip?key=${System.getenv("crowdinKey")}"
                dest output
                overwrite true
            }
        }
    }

    task crowdin(type: Zip) {
        duplicatesStrategy = "include"
        dependsOn downloadCrowdin
        onlyIf {
            !downloadCrowdin.state.skipped
        }
        baseName = project.name
        version = project.version
        classifier = 'crowdin'
        destinationDir = file('build/distributions')
        from(zipTree(downloadCrowdin.output)){
            eachFile {
                if (!it.path.startsWith('assets/')) {
                    it.relativePath = new RelativePath(true, it.relativePath.segments.drop(4))
                }
            }
            exclude { it.isDirectory() }
            rename { it.toLowerCase() }
        }
    }

    tasks.processResources.dependsOn crowdin
}

tasks.withType(org.gradle.api.tasks.Copy.class, {task ->
    task.duplicatesStrategy 'exclude'
})

tasks.withType(org.gradle.api.tasks.javadoc.Javadoc.class, {task ->
    if (!task.name.toLowerCase().contains("api")) {
        task.options.addStringOption('Xdoclint:none', '-quiet')
    }
})

tasks.withType(Jar.class, {task ->
    task.duplicatesStrategy 'exclude'
})

tasks.withType(GenerateModuleMetadata) {
    enabled = false
}

if (opc.isFeatureEnabled("crowdInTranslationManagement") && opc.hasPropertySet("crowdInDownloadDirectory")) {

    project.crowdin { crowdinSpec ->
        crowdinSpec.credentials { credentialsSpec ->
            credentialsSpec.getToken().set(System.getenv().get("crowdInApiKey"))
        }

        crowdinSpec.configuration { configurationSpec ->
            configurationSpec.getFile().set(file("gradle/crowdin.yml"))
            configurationSpec.tokens.put("%crowdin_download_path%", opc.getProperty("crowdInDownloadDirectory"))

            if (opc.isFeatureEnabled("crowdInBranchSeparation")) {
                configurationSpec.tokens.put("%branch_name%", git.branch.name)
            }
        }

        project.tasks.crowdinBuildProjectTranslation { taskSpec ->
            taskSpec.getWaitForBuilds().set(true)
        }

        def performsTranslationsBuild = false;
        if (!opc.isFeatureEnabled("crowdInBuildingWithFilteredBranches") || (opc.hasPropertySet("crowdInBuildingWithFilteredBranchesSpec") && Pattern.matches(opc.getProperty("crowdInBuildingWithFilteredBranchesSpec"), git.branch.name)))
        {
            tasks.processResources.dependsOn crowdinBuildProjectTranslation
            performsTranslationsBuild = true;
        }
        if (!opc.isFeatureEnabled("crowdInUploadWithFilteredBranches") || (opc.hasPropertySet("crowdInUploadWithFilteredBranchesSpec") && Pattern.matches(opc.getProperty("crowdInUploadWithFilteredBranchesSpec"), git.branch.name)))
        {
            tasks.processResources.dependsOn crowdinUploadSourceFiles
            if (performsTranslationsBuild) {
                tasks.crowdinBuildProjectTranslation.dependsOn crowdinUploadSourceFiles
            }
        }

        task deleteTranslationFilesInBuildDir(type: Delete) {
            group "crowdin"
            dependsOn crowdinCopyProjectTranslations
            delete project.buildDir.toPath().resolve("temp").resolve("translations")
            followSymlinks = true
        }

        task normalizeTranslationFilesToBuildDir(type: Copy) {
            group "crowdin"
            dependsOn deleteTranslationFilesInBuildDir
            from project.rootDir.toPath().resolve(opc.getProperty("crowdInDownloadDirectory")).toFile()
            into project.buildDir.toPath().resolve("temp").resolve("translations")
            rename { String name -> name.toLowerCase() }
        }

        task deleteTranslationFilesInRuntimeDir(type: Delete) {
            group "crowdin"
            dependsOn normalizeTranslationFilesToBuildDir
            delete project.rootDir.toPath().resolve(opc.getProperty("crowdInDownloadDirectory")).toFile()
            followSymlinks = true
        }

        task normalizeTranslationFilesToRuntimeDir(type: Copy) {
            group "crowdin"
            dependsOn deleteTranslationFilesInRuntimeDir
            from project.buildDir.toPath().resolve("temp").resolve("translations")
            into project.rootDir.toPath().resolve(opc.getProperty("crowdInDownloadDirectory")).toFile()
            rename { String name -> name.toLowerCase() }
        }

        tasks.crowdinCopyProjectTranslations.dependsOn crowdinDownloadProjectTranslation
        tasks.processResources.dependsOn normalizeTranslationFilesToRuntimeDir
        tasks.sourcesJar.dependsOn normalizeTranslationFilesToRuntimeDir

    }
    else
    {
        project.afterEvaluate {
            project.logger.lifecycle "No CrowdIn API Key was provided. Can not sync translations!"
        }
    }
}
else
{
    project.logger.lifecycle "CrowdIn disabled."
}

fileTree('gradle') {
    include '**/*.gradle'
}.visit { FileVisitDetails details ->
    if (details.file.isDirectory())
        return

    if (details.file.name.contains("local"))
        return

    project.logger.lifecycle "Loading additional configuration from: ${details.file.path}"
    apply from: details.file.path
}

if (project.file("gradle/local.gradle").exists()) {
    project.logger.lifecycle "Loading additional configuration from: ${project.file("gradle/local.gradle").path}"
    apply from: "gradle/local.gradle"
}

project.getLogger().lifecycle("Loaded remote build.gradle with version: " + project.version)